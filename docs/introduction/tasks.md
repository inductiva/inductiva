# Tasks

At the heart of the API lies the concept of a `Task`.
A task is an abstraction that encapsulates all the information about the
computational workload generated by the user. A task is generated when a
simulation is submitted to the API and exists until the user deletes it.
With a task at hand, the user can manage the simulation, retrieve its status,
download its output files, and more.

In this section, we will cover the following topics:
- creating a task, including retrieving tasks from previous sessions;
- managing a task;
- monitoring a task;
- using the task to retrieve the results of a simulation.


## Task Creation

A task is created when a simulation is submitted to the API through a call to the
`run` method of a simulator object. _N_ calls to that method using the same
arguments will produce _N_ tasks, all referring to distinct executions of the
same simulator to perform the same simulation. In the following snippet, we show
how to create a task by submitting a SpliSHSPlasH simulation to the API.

```python
# Example of how to run the SplishSplash simulator
import inductiva

# get some example input files
input_dir = inductiva.utils.download_from_url(
    "https://storage.googleapis.com/inductiva-api-demo-files/"
    "splishsplash-input-example.zip", unzip=True)

# Instantiate the simulator
splishsplash_simulator = inductiva.simulators.SplishSplash()

# SPlisHSPlasH requires a .json file as the main config file.
task = splishsplash_simulator.run(input_dir="splishsplash-input-example",
                                  sim_config_filename="config.json")
print(task.id)  # outputs i4ir3kvv62odsfrhko4y8w2an (example id)

# Note that the following call to splishsplash_simulator.run() using the same
# input arguments would create a new and distinct task
# task2 = splishsplash_simulator.run(input_dir="splishsplash-example",
#                                  sim_config_filename="config.json")
# print (task2.id)  # outputs k9muu1vq1fc6m2oyxm0n3n8y0 (example id)

```

A task is uniquely identified by an alphanumeric identifier which is unique across
all tasks submitted to the API by the user. However, a user can create multiple
`Task` objects that point to the same task by instantiating the `Task` class with
the same identifier without this resulting in the creation of new tasks on the
API; they will be different Python objects, but they will refer to the same task
on the API. This mechanism is useful when the user wants to recreate a `Task`
object to retrieve information about tasks created in previous sessions.

```python
>>> import inductiva
>>>
>>> task1 = inductiva.tasks.Task("i4ir3kvv62odsfrhko4y8w2an")
>>> task2 = inductiva.tasks.Task("i4ir3kvv62odsfrhko4y8w2an")
>>> print(id(task1))
4410160112 
>>> print(id(task2))
4389863104
>>> print(task1.id)
i4ir3kvv62odsfrhko4y8w2an
>>> print(task2.id)
i4ir3kvv62odsfrhko4y8w2an  # the same as task1.id
```

### Managing a task

The `Task` class provides mechanisms to track and manage the status of a task.
With a `Task` object at hand, the user can:
 * Get the status, i.e., whether the task is running, has finished, has failed, etc;
 (see section about [task lifecycle](#task-lifecycle) for more details);
 * Get the machine type where it ran/is running;
 * Get the execution time.
 * Download either all or just a subset of the output files produced by the task;
 * Turning it into a blocking call;
 * Kill it;

The following snippets show how to use the `Task` class to manage a task.

```python
# create a new task or retrieve a task from a previous session
# task = simulator.run(...)
#   or 
# task = Task(i4ir3kvv62odsfrhko4y8w2an)

# Get status of the task.
>>> task.get_status()
<DynamicSchema: 'success'>

# Get the computational resource type where the task is
# running or was submitted to
>>> task.get_machine_type()
'c2-standard-4'

>>> task.get_computation_time()
'00:03:12

# kill a task that hasn't completed yet
>>> task.kill()

# Get information about the output files generated by the simulation
>>> output_files_info = task.get_output_files_info()
>>> print(output_files_info)
Archive size: 262.00 KB
Contents:
  Size         Compressed   Name
  3.12 KB      859 B        stdout.txt
  242 B        160 B        stderr.txt
  5.76 KB      4.10 KB      vtk/ParticleData_Fluid_40.vtk
  5.76 KB      4.09 KB      vtk/ParticleData_Fluid_32.vtk
  5.76 KB      4.09 KB      vtk/ParticleData_Fluid_17.vtk
  ...
  4.98 KB      989 B        log/SPH_log.txt

```

Most of the methods of the `Task` class in the snippet above accept multiple
arguments to configure the action to be performed. For example, the `download_outputs`
method allows the user to specify which files to download and where to save
the downloaded files.
Please refer to the [Task API documentation](../api/inductiva.tasks.html) for more
information on the methods available in the `Task` class.

#### Downloading outputs

Downloading the outputs of a task is a common operation. The user can download
all the files produced by a finished task in a straightforward manner:

```python
# Download all the files produced by the task
>>> output_dir = task.download_outputs()
Downloading simulation outputs to inductiva_output/i4ir3kvv62odsfrhko4y8w2an/output.zip.
100%|██████████████████████████████████████| 5.04M/5.04M [00:00<00:00, 13.3MB/s]
Uncompressing the outputs to inductiva_output/i4ir3kvv62odsfrhko4y8w2an/
>>> print(ouptut_dir)
PosixPath('inductiva_output/i4ir3kvv62odsfrhko4y8w2an')
```

The downloaded files can be inspected using the `ls` command:

```bash
$ ls -1 inductiva_output/i4ir3kvv62odsfrhko4y8w2an
log
stderr.txt
stdout.txt
vtk
```

By default, all output files are downloaded to a directory named after the task
into a parent directory named `inductiva_output`. For example, the outputs
of the task with id `abc123` would be downloaded to `inductiva_output/abc123/`.
The name of the parent directory is a package-level variable that applies to all
downloads with a session. It prevents the user from cluttering the current
working directory with a large number of downloaded files. However, the user can
change this behavior by setting the parent directory name using the
`inductiva.set_output_dir` function.

```python
>>> import inductiva
# set the parent directory name
>>> inductiva.get_output_dir()
'inductiva_output'
>>> inductiva.set_output_dir("my_vault")
>>> inductiva.get_output_dir()
'my_vault'

# download the outputs again
>>> output_dir = task.download_outputs()
Downloading simulation outputs to my_vault/i4ir3kvv62odsfrhko4y8w2an/output.zip.
100%|██████████████████████████████████████| 5.04M/5.04M [00:00<00:00, 13.3MB/s]
Uncompressing the outputs to my_vault/i4ir3kvv62odsfrhko4y8w2an/
>>> print(ouptut_dir)
PosixPath('my_vault/i4ir3kvv62odsfrhko4y8w2an')

# Unset the parent directory name so that all downloads are done to the current
# working directory
>>> inductiva.set_output_dir("None")
>>> output_dir = task.download_outputs()
Downloading simulation outputs to i4ir3kvv62odsfrhko4y8w2an/output.zip.
100%|██████████████████████████████████████| 5.04M/5.04M [00:00<00:00, 13.3MB/s]
Uncompressing the outputs to i4ir3kvv62odsfrhko4y8w2an/
>>> print(ouptut_dir)
PosixPath('i4ir3kvv62odsfrhko4y8w2an')
```

The `download_outputs` method of the `Task` class has the option to specify the
name of the folder where the outputs are downloaded inside the parent directory.

```python
# reset the parent directory name to the default
>>> inductiva.set_output_dir("inductiva_outputs")
>>> output_dir = task.download_outputs(output_dir="my_outputs")
Downloading simulation outputs to inductiva_output/my_outputs/output.zip.
100%|██████████████████████████████████████| 5.04M/5.04M [00:00<00:00, 13.3MB/s]
Uncompressing the outputs to inductiva_output/my_outputs/
>>> print(ouptut_dir)
PosixPath('inductiva_output/my_outputs')
```

In addition to controlling how downloaded files are organized, the user can also
configure which files to download. By default, all files produced by the task are
downloaded. However, the user can download only a subset of those files by
specifying the filenames of interest:

```python
# Download only the files of interest
>>> output_dir = task.download_outputs(filenames=["stdout.txt", "stderr.txt"]
                                       output_dir="my_outputs")
Downloading simulation outputs to inductiva_output/my_outputs/output.zip.
100%|██████████████████████████████████████| 1.04k/1.04k [00:00<00:00, 671kB/s]
Uncompressing the outputs to inductiva_output/my_outputs/
```
In this case, we can confirm that only the files `stdout.txt` and `stderr.txt`
were indeed downloaded:

```bash
$ ls -1 inductiva_output/my_outputs
stderr.txt
stdout.txt
```

### Synchronous tasks

Tasks are asynchronous by default. This means that the user can continue to
interact with the API while the task is running or queued up for execution.
This behavior allows the user to submit batches of tasks in a single session
knowing that the API will take care of the parallel execution of the tasks

However, the user can turn a task into a blocking call by using the `wait` method.
This method will block the call until the task comes to a terminal status, but
without interrupting the remote simulation if the local session is interrupted
(ex. the script is abruptly terminated). This is useful when the user wants to
wait for the completion of a task before proceeding with some other operation
(ex. downloading the output files).

```python
# Block the call until the simulation completes
task.wait()  # <- The remote simulation WILL NOT DIE if the local session is
             #    interrupted while waiting for the wait() call to return
```

Alternatively, the user can turn the simulation into a blocking call by using
the `sync_context`context manager. This context manager ensures that the remote
simulation is indeed killed if the local session is interrupted while waiting
for the `wait` call to return.

```python
# Block the call until the simulation completes
with task.sync_context():
    task.wait()  # <-- The remote simulation WILL DIE if the local session is
                 #     interrupted while waiting for the wait() call to return
                 #     Ex. the user presses Ctrl+C while waiting for the call to
                 #     return
```


### Task Lifecycle


The status of a task changes as it progresses through its lifecycle. Each task
is created by the user when a simulation is submitted to the API but it then
undergoes various state transitions that reflect the progress of the user's
request through the API.

The following diagram shows the lifecycle of a task:


<div align="center">
   <img src="../_static/task_state.svg" alt="Task state diagram">
</div>


