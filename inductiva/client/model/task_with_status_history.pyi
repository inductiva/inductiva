# coding: utf-8
"""
    InductivaWebAPI

    No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)  # noqa: E501

    The version of the OpenAPI document: 0.1.0
    Generated by: https://openapi-generator.tech
"""

from datetime import date, datetime  # noqa: F401
import decimal  # noqa: F401
import functools  # noqa: F401
import io  # noqa: F401
import re  # noqa: F401
import typing  # noqa: F401
import typing_extensions  # noqa: F401
import uuid  # noqa: F401

import frozendict  # noqa: F401

from inductiva.client import schemas  # noqa: F401


class TaskWithStatusHistory(schemas.DictSchema):
    """NOTE: This class is auto generated by OpenAPI Generator.
    Ref: https://openapi-generator.tech

    Do not edit the class manually.
    """

    class MetaOapg:
        required = {
            "simulator",
            "status_alias",
            "status_history",
            "project",
            "task_id",
            "machine_operations",
            "is_terminated",
            "status",
        }

        class properties:
            task_id = schemas.StrSchema

            @staticmethod
            def status() -> typing.Type['TaskStatusCode']:
                return TaskStatusCode

            status_alias = schemas.StrSchema
            simulator = schemas.StrSchema
            project = schemas.StrSchema
            is_terminated = schemas.BoolSchema

            class status_history(schemas.ListSchema):

                class MetaOapg:

                    @staticmethod
                    def items() -> typing.Type['TaskStatusInfo']:
                        return TaskStatusInfo

                def __new__(
                    cls,
                    _arg: typing.Union[typing.Tuple['TaskStatusInfo'],
                                       typing.List['TaskStatusInfo']],
                    _configuration: typing.Optional[
                        schemas.Configuration] = None,
                ) -> 'status_history':
                    return super().__new__(
                        cls,
                        _arg,
                        _configuration=_configuration,
                    )

                def __getitem__(self, i: int) -> 'TaskStatusInfo':
                    return super().__getitem__(i)

            class machine_operations(schemas.ListSchema):

                class MetaOapg:

                    @staticmethod
                    def items() -> typing.Type['TaskMachineOperation']:
                        return TaskMachineOperation

                def __new__(
                    cls,
                    _arg: typing.Union[typing.Tuple['TaskMachineOperation'],
                                       typing.List['TaskMachineOperation']],
                    _configuration: typing.Optional[
                        schemas.Configuration] = None,
                ) -> 'machine_operations':
                    return super().__new__(
                        cls,
                        _arg,
                        _configuration=_configuration,
                    )

                def __getitem__(self, i: int) -> 'TaskMachineOperation':
                    return super().__getitem__(i)

            class storage_path(
                    schemas.ComposedSchema,):

                class MetaOapg:
                    any_of_0 = schemas.StrSchema
                    any_of_1 = schemas.NoneSchema

                    @classmethod
                    @functools.lru_cache()
                    def any_of(cls):
                        # we need this here to make our import statements work
                        # we must store _composed_schemas in here so the code is only run
                        # when we invoke this method. If we kept this at the class
                        # level we would get an error because the class level
                        # code would be run when this module is imported, and these composed
                        # classes don't exist yet because their module has not finished
                        # loading
                        return [
                            cls.any_of_0,
                            cls.any_of_1,
                        ]

                def __new__(
                    cls,
                    *_args: typing.Union[
                        dict,
                        frozendict.frozendict,
                        str,
                        date,
                        datetime,
                        uuid.UUID,
                        int,
                        float,
                        decimal.Decimal,
                        bool,
                        None,
                        list,
                        tuple,
                        bytes,
                        io.FileIO,
                        io.BufferedReader,
                    ],
                    _configuration: typing.Optional[
                        schemas.Configuration] = None,
                    **kwargs: typing.Union[schemas.AnyTypeSchema, dict,
                                           frozendict.frozendict, str, date,
                                           datetime, uuid.UUID, int, float,
                                           decimal.Decimal, None, list, tuple,
                                           bytes],
                ) -> 'storage_path':
                    return super().__new__(
                        cls,
                        *_args,
                        _configuration=_configuration,
                        **kwargs,
                    )

            class container_image(
                    schemas.ComposedSchema,):

                class MetaOapg:
                    any_of_0 = schemas.StrSchema
                    any_of_1 = schemas.NoneSchema

                    @classmethod
                    @functools.lru_cache()
                    def any_of(cls):
                        # we need this here to make our import statements work
                        # we must store _composed_schemas in here so the code is only run
                        # when we invoke this method. If we kept this at the class
                        # level we would get an error because the class level
                        # code would be run when this module is imported, and these composed
                        # classes don't exist yet because their module has not finished
                        # loading
                        return [
                            cls.any_of_0,
                            cls.any_of_1,
                        ]

                def __new__(
                    cls,
                    *_args: typing.Union[
                        dict,
                        frozendict.frozendict,
                        str,
                        date,
                        datetime,
                        uuid.UUID,
                        int,
                        float,
                        decimal.Decimal,
                        bool,
                        None,
                        list,
                        tuple,
                        bytes,
                        io.FileIO,
                        io.BufferedReader,
                    ],
                    _configuration: typing.Optional[
                        schemas.Configuration] = None,
                    **kwargs: typing.Union[schemas.AnyTypeSchema, dict,
                                           frozendict.frozendict, str, date,
                                           datetime, uuid.UUID, int, float,
                                           decimal.Decimal, None, list, tuple,
                                           bytes],
                ) -> 'container_image':
                    return super().__new__(
                        cls,
                        *_args,
                        _configuration=_configuration,
                        **kwargs,
                    )

            class create_time(
                    schemas.DateTimeBase,
                    schemas.ComposedSchema,
            ):

                class MetaOapg:
                    format = 'date-time'
                    any_of_0 = schemas.StrSchema
                    any_of_1 = schemas.NoneSchema

                    @classmethod
                    @functools.lru_cache()
                    def any_of(cls):
                        # we need this here to make our import statements work
                        # we must store _composed_schemas in here so the code is only run
                        # when we invoke this method. If we kept this at the class
                        # level we would get an error because the class level
                        # code would be run when this module is imported, and these composed
                        # classes don't exist yet because their module has not finished
                        # loading
                        return [
                            cls.any_of_0,
                            cls.any_of_1,
                        ]

                def __new__(
                    cls,
                    *_args: typing.Union[
                        dict,
                        frozendict.frozendict,
                        str,
                        date,
                        datetime,
                        uuid.UUID,
                        int,
                        float,
                        decimal.Decimal,
                        bool,
                        None,
                        list,
                        tuple,
                        bytes,
                        io.FileIO,
                        io.BufferedReader,
                    ],
                    _configuration: typing.Optional[
                        schemas.Configuration] = None,
                    **kwargs: typing.Union[schemas.AnyTypeSchema, dict,
                                           frozendict.frozendict, str, date,
                                           datetime, uuid.UUID, int, float,
                                           decimal.Decimal, None, list, tuple,
                                           bytes],
                ) -> 'create_time':
                    return super().__new__(
                        cls,
                        *_args,
                        _configuration=_configuration,
                        **kwargs,
                    )

            class input_submit_time(
                    schemas.DateTimeBase,
                    schemas.ComposedSchema,
            ):

                class MetaOapg:
                    format = 'date-time'
                    any_of_0 = schemas.StrSchema
                    any_of_1 = schemas.NoneSchema

                    @classmethod
                    @functools.lru_cache()
                    def any_of(cls):
                        # we need this here to make our import statements work
                        # we must store _composed_schemas in here so the code is only run
                        # when we invoke this method. If we kept this at the class
                        # level we would get an error because the class level
                        # code would be run when this module is imported, and these composed
                        # classes don't exist yet because their module has not finished
                        # loading
                        return [
                            cls.any_of_0,
                            cls.any_of_1,
                        ]

                def __new__(
                    cls,
                    *_args: typing.Union[
                        dict,
                        frozendict.frozendict,
                        str,
                        date,
                        datetime,
                        uuid.UUID,
                        int,
                        float,
                        decimal.Decimal,
                        bool,
                        None,
                        list,
                        tuple,
                        bytes,
                        io.FileIO,
                        io.BufferedReader,
                    ],
                    _configuration: typing.Optional[
                        schemas.Configuration] = None,
                    **kwargs: typing.Union[schemas.AnyTypeSchema, dict,
                                           frozendict.frozendict, str, date,
                                           datetime, uuid.UUID, int, float,
                                           decimal.Decimal, None, list, tuple,
                                           bytes],
                ) -> 'input_submit_time':
                    return super().__new__(
                        cls,
                        *_args,
                        _configuration=_configuration,
                        **kwargs,
                    )

            class start_time(
                    schemas.DateTimeBase,
                    schemas.ComposedSchema,
            ):

                class MetaOapg:
                    format = 'date-time'
                    any_of_0 = schemas.StrSchema
                    any_of_1 = schemas.NoneSchema

                    @classmethod
                    @functools.lru_cache()
                    def any_of(cls):
                        # we need this here to make our import statements work
                        # we must store _composed_schemas in here so the code is only run
                        # when we invoke this method. If we kept this at the class
                        # level we would get an error because the class level
                        # code would be run when this module is imported, and these composed
                        # classes don't exist yet because their module has not finished
                        # loading
                        return [
                            cls.any_of_0,
                            cls.any_of_1,
                        ]

                def __new__(
                    cls,
                    *_args: typing.Union[
                        dict,
                        frozendict.frozendict,
                        str,
                        date,
                        datetime,
                        uuid.UUID,
                        int,
                        float,
                        decimal.Decimal,
                        bool,
                        None,
                        list,
                        tuple,
                        bytes,
                        io.FileIO,
                        io.BufferedReader,
                    ],
                    _configuration: typing.Optional[
                        schemas.Configuration] = None,
                    **kwargs: typing.Union[schemas.AnyTypeSchema, dict,
                                           frozendict.frozendict, str, date,
                                           datetime, uuid.UUID, int, float,
                                           decimal.Decimal, None, list, tuple,
                                           bytes],
                ) -> 'start_time':
                    return super().__new__(
                        cls,
                        *_args,
                        _configuration=_configuration,
                        **kwargs,
                    )

            class computation_start_time(
                    schemas.DateTimeBase,
                    schemas.ComposedSchema,
            ):

                class MetaOapg:
                    format = 'date-time'
                    any_of_0 = schemas.StrSchema
                    any_of_1 = schemas.NoneSchema

                    @classmethod
                    @functools.lru_cache()
                    def any_of(cls):
                        # we need this here to make our import statements work
                        # we must store _composed_schemas in here so the code is only run
                        # when we invoke this method. If we kept this at the class
                        # level we would get an error because the class level
                        # code would be run when this module is imported, and these composed
                        # classes don't exist yet because their module has not finished
                        # loading
                        return [
                            cls.any_of_0,
                            cls.any_of_1,
                        ]

                def __new__(
                    cls,
                    *_args: typing.Union[
                        dict,
                        frozendict.frozendict,
                        str,
                        date,
                        datetime,
                        uuid.UUID,
                        int,
                        float,
                        decimal.Decimal,
                        bool,
                        None,
                        list,
                        tuple,
                        bytes,
                        io.FileIO,
                        io.BufferedReader,
                    ],
                    _configuration: typing.Optional[
                        schemas.Configuration] = None,
                    **kwargs: typing.Union[schemas.AnyTypeSchema, dict,
                                           frozendict.frozendict, str, date,
                                           datetime, uuid.UUID, int, float,
                                           decimal.Decimal, None, list, tuple,
                                           bytes],
                ) -> 'computation_start_time':
                    return super().__new__(
                        cls,
                        *_args,
                        _configuration=_configuration,
                        **kwargs,
                    )

            class computation_end_time(
                    schemas.DateTimeBase,
                    schemas.ComposedSchema,
            ):

                class MetaOapg:
                    format = 'date-time'
                    any_of_0 = schemas.StrSchema
                    any_of_1 = schemas.NoneSchema

                    @classmethod
                    @functools.lru_cache()
                    def any_of(cls):
                        # we need this here to make our import statements work
                        # we must store _composed_schemas in here so the code is only run
                        # when we invoke this method. If we kept this at the class
                        # level we would get an error because the class level
                        # code would be run when this module is imported, and these composed
                        # classes don't exist yet because their module has not finished
                        # loading
                        return [
                            cls.any_of_0,
                            cls.any_of_1,
                        ]

                def __new__(
                    cls,
                    *_args: typing.Union[
                        dict,
                        frozendict.frozendict,
                        str,
                        date,
                        datetime,
                        uuid.UUID,
                        int,
                        float,
                        decimal.Decimal,
                        bool,
                        None,
                        list,
                        tuple,
                        bytes,
                        io.FileIO,
                        io.BufferedReader,
                    ],
                    _configuration: typing.Optional[
                        schemas.Configuration] = None,
                    **kwargs: typing.Union[schemas.AnyTypeSchema, dict,
                                           frozendict.frozendict, str, date,
                                           datetime, uuid.UUID, int, float,
                                           decimal.Decimal, None, list, tuple,
                                           bytes],
                ) -> 'computation_end_time':
                    return super().__new__(
                        cls,
                        *_args,
                        _configuration=_configuration,
                        **kwargs,
                    )

            class end_time(
                    schemas.DateTimeBase,
                    schemas.ComposedSchema,
            ):

                class MetaOapg:
                    format = 'date-time'
                    any_of_0 = schemas.StrSchema
                    any_of_1 = schemas.NoneSchema

                    @classmethod
                    @functools.lru_cache()
                    def any_of(cls):
                        # we need this here to make our import statements work
                        # we must store _composed_schemas in here so the code is only run
                        # when we invoke this method. If we kept this at the class
                        # level we would get an error because the class level
                        # code would be run when this module is imported, and these composed
                        # classes don't exist yet because their module has not finished
                        # loading
                        return [
                            cls.any_of_0,
                            cls.any_of_1,
                        ]

                def __new__(
                    cls,
                    *_args: typing.Union[
                        dict,
                        frozendict.frozendict,
                        str,
                        date,
                        datetime,
                        uuid.UUID,
                        int,
                        float,
                        decimal.Decimal,
                        bool,
                        None,
                        list,
                        tuple,
                        bytes,
                        io.FileIO,
                        io.BufferedReader,
                    ],
                    _configuration: typing.Optional[
                        schemas.Configuration] = None,
                    **kwargs: typing.Union[schemas.AnyTypeSchema, dict,
                                           frozendict.frozendict, str, date,
                                           datetime, uuid.UUID, int, float,
                                           decimal.Decimal, None, list, tuple,
                                           bytes],
                ) -> 'end_time':
                    return super().__new__(
                        cls,
                        *_args,
                        _configuration=_configuration,
                        **kwargs,
                    )

            class estimated_computation_cost(
                    schemas.ComposedSchema,):

                class MetaOapg:
                    any_of_0 = schemas.NumberSchema
                    any_of_1 = schemas.NoneSchema

                    @classmethod
                    @functools.lru_cache()
                    def any_of(cls):
                        # we need this here to make our import statements work
                        # we must store _composed_schemas in here so the code is only run
                        # when we invoke this method. If we kept this at the class
                        # level we would get an error because the class level
                        # code would be run when this module is imported, and these composed
                        # classes don't exist yet because their module has not finished
                        # loading
                        return [
                            cls.any_of_0,
                            cls.any_of_1,
                        ]

                def __new__(
                    cls,
                    *_args: typing.Union[
                        dict,
                        frozendict.frozendict,
                        str,
                        date,
                        datetime,
                        uuid.UUID,
                        int,
                        float,
                        decimal.Decimal,
                        bool,
                        None,
                        list,
                        tuple,
                        bytes,
                        io.FileIO,
                        io.BufferedReader,
                    ],
                    _configuration: typing.Optional[
                        schemas.Configuration] = None,
                    **kwargs: typing.Union[schemas.AnyTypeSchema, dict,
                                           frozendict.frozendict, str, date,
                                           datetime, uuid.UUID, int, float,
                                           decimal.Decimal, None, list, tuple,
                                           bytes],
                ) -> 'estimated_computation_cost':
                    return super().__new__(
                        cls,
                        *_args,
                        _configuration=_configuration,
                        **kwargs,
                    )

            class storage_size(
                    schemas.ComposedSchema,):

                class MetaOapg:
                    any_of_0 = schemas.IntSchema
                    any_of_1 = schemas.NoneSchema

                    @classmethod
                    @functools.lru_cache()
                    def any_of(cls):
                        # we need this here to make our import statements work
                        # we must store _composed_schemas in here so the code is only run
                        # when we invoke this method. If we kept this at the class
                        # level we would get an error because the class level
                        # code would be run when this module is imported, and these composed
                        # classes don't exist yet because their module has not finished
                        # loading
                        return [
                            cls.any_of_0,
                            cls.any_of_1,
                        ]

                def __new__(
                    cls,
                    *_args: typing.Union[
                        dict,
                        frozendict.frozendict,
                        str,
                        date,
                        datetime,
                        uuid.UUID,
                        int,
                        float,
                        decimal.Decimal,
                        bool,
                        None,
                        list,
                        tuple,
                        bytes,
                        io.FileIO,
                        io.BufferedReader,
                    ],
                    _configuration: typing.Optional[
                        schemas.Configuration] = None,
                    **kwargs: typing.Union[schemas.AnyTypeSchema, dict,
                                           frozendict.frozendict, str, date,
                                           datetime, uuid.UUID, int, float,
                                           decimal.Decimal, None, list, tuple,
                                           bytes],
                ) -> 'storage_size':
                    return super().__new__(
                        cls,
                        *_args,
                        _configuration=_configuration,
                        **kwargs,
                    )

            class metrics(
                    schemas.ComposedSchema,):

                class MetaOapg:
                    any_of_1 = schemas.NoneSchema

                    @classmethod
                    @functools.lru_cache()
                    def any_of(cls):
                        # we need this here to make our import statements work
                        # we must store _composed_schemas in here so the code is only run
                        # when we invoke this method. If we kept this at the class
                        # level we would get an error because the class level
                        # code would be run when this module is imported, and these composed
                        # classes don't exist yet because their module has not finished
                        # loading
                        return [
                            TaskMetrics,
                            cls.any_of_1,
                        ]

                def __new__(
                    cls,
                    *_args: typing.Union[
                        dict,
                        frozendict.frozendict,
                        str,
                        date,
                        datetime,
                        uuid.UUID,
                        int,
                        float,
                        decimal.Decimal,
                        bool,
                        None,
                        list,
                        tuple,
                        bytes,
                        io.FileIO,
                        io.BufferedReader,
                    ],
                    _configuration: typing.Optional[
                        schemas.Configuration] = None,
                    **kwargs: typing.Union[schemas.AnyTypeSchema, dict,
                                           frozendict.frozendict, str, date,
                                           datetime, uuid.UUID, int, float,
                                           decimal.Decimal, None, list, tuple,
                                           bytes],
                ) -> 'metrics':
                    return super().__new__(
                        cls,
                        *_args,
                        _configuration=_configuration,
                        **kwargs,
                    )

            class executer(
                    schemas.ComposedSchema,):

                class MetaOapg:
                    any_of_1 = schemas.NoneSchema

                    @classmethod
                    @functools.lru_cache()
                    def any_of(cls):
                        # we need this here to make our import statements work
                        # we must store _composed_schemas in here so the code is only run
                        # when we invoke this method. If we kept this at the class
                        # level we would get an error because the class level
                        # code would be run when this module is imported, and these composed
                        # classes don't exist yet because their module has not finished
                        # loading
                        return [
                            Executer,
                            cls.any_of_1,
                        ]

                def __new__(
                    cls,
                    *_args: typing.Union[
                        dict,
                        frozendict.frozendict,
                        str,
                        date,
                        datetime,
                        uuid.UUID,
                        int,
                        float,
                        decimal.Decimal,
                        bool,
                        None,
                        list,
                        tuple,
                        bytes,
                        io.FileIO,
                        io.BufferedReader,
                    ],
                    _configuration: typing.Optional[
                        schemas.Configuration] = None,
                    **kwargs: typing.Union[schemas.AnyTypeSchema, dict,
                                           frozendict.frozendict, str, date,
                                           datetime, uuid.UUID, int, float,
                                           decimal.Decimal, None, list, tuple,
                                           bytes],
                ) -> 'executer':
                    return super().__new__(
                        cls,
                        *_args,
                        _configuration=_configuration,
                        **kwargs,
                    )

            class machine_group_name(
                    schemas.ComposedSchema,):

                class MetaOapg:
                    any_of_0 = schemas.StrSchema
                    any_of_1 = schemas.NoneSchema

                    @classmethod
                    @functools.lru_cache()
                    def any_of(cls):
                        # we need this here to make our import statements work
                        # we must store _composed_schemas in here so the code is only run
                        # when we invoke this method. If we kept this at the class
                        # level we would get an error because the class level
                        # code would be run when this module is imported, and these composed
                        # classes don't exist yet because their module has not finished
                        # loading
                        return [
                            cls.any_of_0,
                            cls.any_of_1,
                        ]

                def __new__(
                    cls,
                    *_args: typing.Union[
                        dict,
                        frozendict.frozendict,
                        str,
                        date,
                        datetime,
                        uuid.UUID,
                        int,
                        float,
                        decimal.Decimal,
                        bool,
                        None,
                        list,
                        tuple,
                        bytes,
                        io.FileIO,
                        io.BufferedReader,
                    ],
                    _configuration: typing.Optional[
                        schemas.Configuration] = None,
                    **kwargs: typing.Union[schemas.AnyTypeSchema, dict,
                                           frozendict.frozendict, str, date,
                                           datetime, uuid.UUID, int, float,
                                           decimal.Decimal, None, list, tuple,
                                           bytes],
                ) -> 'machine_group_name':
                    return super().__new__(
                        cls,
                        *_args,
                        _configuration=_configuration,
                        **kwargs,
                    )

            class machine_group_id(
                    schemas.UUIDBase,
                    schemas.ComposedSchema,
            ):

                class MetaOapg:
                    format = 'uuid'
                    any_of_0 = schemas.StrSchema
                    any_of_1 = schemas.NoneSchema

                    @classmethod
                    @functools.lru_cache()
                    def any_of(cls):
                        # we need this here to make our import statements work
                        # we must store _composed_schemas in here so the code is only run
                        # when we invoke this method. If we kept this at the class
                        # level we would get an error because the class level
                        # code would be run when this module is imported, and these composed
                        # classes don't exist yet because their module has not finished
                        # loading
                        return [
                            cls.any_of_0,
                            cls.any_of_1,
                        ]

                def __new__(
                    cls,
                    *_args: typing.Union[
                        dict,
                        frozendict.frozendict,
                        str,
                        date,
                        datetime,
                        uuid.UUID,
                        int,
                        float,
                        decimal.Decimal,
                        bool,
                        None,
                        list,
                        tuple,
                        bytes,
                        io.FileIO,
                        io.BufferedReader,
                    ],
                    _configuration: typing.Optional[
                        schemas.Configuration] = None,
                    **kwargs: typing.Union[schemas.AnyTypeSchema, dict,
                                           frozendict.frozendict, str, date,
                                           datetime, uuid.UUID, int, float,
                                           decimal.Decimal, None, list, tuple,
                                           bytes],
                ) -> 'machine_group_id':
                    return super().__new__(
                        cls,
                        *_args,
                        _configuration=_configuration,
                        **kwargs,
                    )

            class error_detail(
                    schemas.ComposedSchema,):

                class MetaOapg:
                    any_of_0 = schemas.StrSchema
                    any_of_1 = schemas.NoneSchema

                    @classmethod
                    @functools.lru_cache()
                    def any_of(cls):
                        # we need this here to make our import statements work
                        # we must store _composed_schemas in here so the code is only run
                        # when we invoke this method. If we kept this at the class
                        # level we would get an error because the class level
                        # code would be run when this module is imported, and these composed
                        # classes don't exist yet because their module has not finished
                        # loading
                        return [
                            cls.any_of_0,
                            cls.any_of_1,
                        ]

                def __new__(
                    cls,
                    *_args: typing.Union[
                        dict,
                        frozendict.frozendict,
                        str,
                        date,
                        datetime,
                        uuid.UUID,
                        int,
                        float,
                        decimal.Decimal,
                        bool,
                        None,
                        list,
                        tuple,
                        bytes,
                        io.FileIO,
                        io.BufferedReader,
                    ],
                    _configuration: typing.Optional[
                        schemas.Configuration] = None,
                    **kwargs: typing.Union[schemas.AnyTypeSchema, dict,
                                           frozendict.frozendict, str, date,
                                           datetime, uuid.UUID, int, float,
                                           decimal.Decimal, None, list, tuple,
                                           bytes],
                ) -> 'error_detail':
                    return super().__new__(
                        cls,
                        *_args,
                        _configuration=_configuration,
                        **kwargs,
                    )

            class input_resources(schemas.ListSchema):

                class MetaOapg:
                    items = schemas.StrSchema

                def __new__(
                    cls,
                    _arg: typing.Union[typing.Tuple[typing.Union[
                        MetaOapg.items,
                        str,
                    ]], typing.List[typing.Union[
                        MetaOapg.items,
                        str,
                    ]]],
                    _configuration: typing.Optional[
                        schemas.Configuration] = None,
                ) -> 'input_resources':
                    return super().__new__(
                        cls,
                        _arg,
                        _configuration=_configuration,
                    )

                def __getitem__(self, i: int) -> MetaOapg.items:
                    return super().__getitem__(i)

            stream_zip = schemas.BoolSchema

            class steps(schemas.ListSchema):

                class MetaOapg:

                    @staticmethod
                    def items() -> typing.Type['TaskStep']:
                        return TaskStep

                def __new__(
                    cls,
                    _arg: typing.Union[typing.Tuple['TaskStep'],
                                       typing.List['TaskStep']],
                    _configuration: typing.Optional[
                        schemas.Configuration] = None,
                ) -> 'steps':
                    return super().__new__(
                        cls,
                        _arg,
                        _configuration=_configuration,
                    )

                def __getitem__(self, i: int) -> 'TaskStep':
                    return super().__getitem__(i)

            __annotations__ = {
                "task_id": task_id,
                "status": status,
                "status_alias": status_alias,
                "simulator": simulator,
                "project": project,
                "is_terminated": is_terminated,
                "status_history": status_history,
                "machine_operations": machine_operations,
                "storage_path": storage_path,
                "container_image": container_image,
                "create_time": create_time,
                "input_submit_time": input_submit_time,
                "start_time": start_time,
                "computation_start_time": computation_start_time,
                "computation_end_time": computation_end_time,
                "end_time": end_time,
                "estimated_computation_cost": estimated_computation_cost,
                "storage_size": storage_size,
                "metrics": metrics,
                "executer": executer,
                "machine_group_name": machine_group_name,
                "machine_group_id": machine_group_id,
                "error_detail": error_detail,
                "input_resources": input_resources,
                "stream_zip": stream_zip,
                "steps": steps,
            }

    simulator: MetaOapg.properties.simulator
    status_alias: MetaOapg.properties.status_alias
    status_history: MetaOapg.properties.status_history
    project: MetaOapg.properties.project
    task_id: MetaOapg.properties.task_id
    machine_operations: MetaOapg.properties.machine_operations
    is_terminated: MetaOapg.properties.is_terminated
    status: 'TaskStatusCode'

    @typing.overload
    def __getitem__(
        self, name: typing_extensions.Literal["task_id"]
    ) -> MetaOapg.properties.task_id:
        ...

    @typing.overload
    def __getitem__(
            self,
            name: typing_extensions.Literal["status"]) -> 'TaskStatusCode':
        ...

    @typing.overload
    def __getitem__(
        self, name: typing_extensions.Literal["status_alias"]
    ) -> MetaOapg.properties.status_alias:
        ...

    @typing.overload
    def __getitem__(
        self, name: typing_extensions.Literal["simulator"]
    ) -> MetaOapg.properties.simulator:
        ...

    @typing.overload
    def __getitem__(
        self, name: typing_extensions.Literal["project"]
    ) -> MetaOapg.properties.project:
        ...

    @typing.overload
    def __getitem__(
        self, name: typing_extensions.Literal["is_terminated"]
    ) -> MetaOapg.properties.is_terminated:
        ...

    @typing.overload
    def __getitem__(
        self, name: typing_extensions.Literal["status_history"]
    ) -> MetaOapg.properties.status_history:
        ...

    @typing.overload
    def __getitem__(
        self, name: typing_extensions.Literal["machine_operations"]
    ) -> MetaOapg.properties.machine_operations:
        ...

    @typing.overload
    def __getitem__(
        self, name: typing_extensions.Literal["storage_path"]
    ) -> MetaOapg.properties.storage_path:
        ...

    @typing.overload
    def __getitem__(
        self, name: typing_extensions.Literal["container_image"]
    ) -> MetaOapg.properties.container_image:
        ...

    @typing.overload
    def __getitem__(
        self, name: typing_extensions.Literal["create_time"]
    ) -> MetaOapg.properties.create_time:
        ...

    @typing.overload
    def __getitem__(
        self, name: typing_extensions.Literal["input_submit_time"]
    ) -> MetaOapg.properties.input_submit_time:
        ...

    @typing.overload
    def __getitem__(
        self, name: typing_extensions.Literal["start_time"]
    ) -> MetaOapg.properties.start_time:
        ...

    @typing.overload
    def __getitem__(
        self, name: typing_extensions.Literal["computation_start_time"]
    ) -> MetaOapg.properties.computation_start_time:
        ...

    @typing.overload
    def __getitem__(
        self, name: typing_extensions.Literal["computation_end_time"]
    ) -> MetaOapg.properties.computation_end_time:
        ...

    @typing.overload
    def __getitem__(
        self, name: typing_extensions.Literal["end_time"]
    ) -> MetaOapg.properties.end_time:
        ...

    @typing.overload
    def __getitem__(
        self, name: typing_extensions.Literal["estimated_computation_cost"]
    ) -> MetaOapg.properties.estimated_computation_cost:
        ...

    @typing.overload
    def __getitem__(
        self, name: typing_extensions.Literal["storage_size"]
    ) -> MetaOapg.properties.storage_size:
        ...

    @typing.overload
    def __getitem__(
        self, name: typing_extensions.Literal["metrics"]
    ) -> MetaOapg.properties.metrics:
        ...

    @typing.overload
    def __getitem__(
        self, name: typing_extensions.Literal["executer"]
    ) -> MetaOapg.properties.executer:
        ...

    @typing.overload
    def __getitem__(
        self, name: typing_extensions.Literal["machine_group_name"]
    ) -> MetaOapg.properties.machine_group_name:
        ...

    @typing.overload
    def __getitem__(
        self, name: typing_extensions.Literal["machine_group_id"]
    ) -> MetaOapg.properties.machine_group_id:
        ...

    @typing.overload
    def __getitem__(
        self, name: typing_extensions.Literal["error_detail"]
    ) -> MetaOapg.properties.error_detail:
        ...

    @typing.overload
    def __getitem__(
        self, name: typing_extensions.Literal["input_resources"]
    ) -> MetaOapg.properties.input_resources:
        ...

    @typing.overload
    def __getitem__(
        self, name: typing_extensions.Literal["stream_zip"]
    ) -> MetaOapg.properties.stream_zip:
        ...

    @typing.overload
    def __getitem__(
            self, name: typing_extensions.Literal["steps"]
    ) -> MetaOapg.properties.steps:
        ...

    @typing.overload
    def __getitem__(self, name: str) -> schemas.UnsetAnyTypeSchema:
        ...

    def __getitem__(self, name: typing.Union[typing_extensions.Literal[
        "task_id",
        "status",
        "status_alias",
        "simulator",
        "project",
        "is_terminated",
        "status_history",
        "machine_operations",
        "storage_path",
        "container_image",
        "create_time",
        "input_submit_time",
        "start_time",
        "computation_start_time",
        "computation_end_time",
        "end_time",
        "estimated_computation_cost",
        "storage_size",
        "metrics",
        "executer",
        "machine_group_name",
        "machine_group_id",
        "error_detail",
        "input_resources",
        "stream_zip",
        "steps",
    ], str]):
        # dict_instance[name] accessor
        return super().__getitem__(name)

    @typing.overload
    def get_item_oapg(
        self, name: typing_extensions.Literal["task_id"]
    ) -> MetaOapg.properties.task_id:
        ...

    @typing.overload
    def get_item_oapg(
            self,
            name: typing_extensions.Literal["status"]) -> 'TaskStatusCode':
        ...

    @typing.overload
    def get_item_oapg(
        self, name: typing_extensions.Literal["status_alias"]
    ) -> MetaOapg.properties.status_alias:
        ...

    @typing.overload
    def get_item_oapg(
        self, name: typing_extensions.Literal["simulator"]
    ) -> MetaOapg.properties.simulator:
        ...

    @typing.overload
    def get_item_oapg(
        self, name: typing_extensions.Literal["project"]
    ) -> MetaOapg.properties.project:
        ...

    @typing.overload
    def get_item_oapg(
        self, name: typing_extensions.Literal["is_terminated"]
    ) -> MetaOapg.properties.is_terminated:
        ...

    @typing.overload
    def get_item_oapg(
        self, name: typing_extensions.Literal["status_history"]
    ) -> MetaOapg.properties.status_history:
        ...

    @typing.overload
    def get_item_oapg(
        self, name: typing_extensions.Literal["machine_operations"]
    ) -> MetaOapg.properties.machine_operations:
        ...

    @typing.overload
    def get_item_oapg(
        self, name: typing_extensions.Literal["storage_path"]
    ) -> typing.Union[MetaOapg.properties.storage_path, schemas.Unset]:
        ...

    @typing.overload
    def get_item_oapg(
        self, name: typing_extensions.Literal["container_image"]
    ) -> typing.Union[MetaOapg.properties.container_image, schemas.Unset]:
        ...

    @typing.overload
    def get_item_oapg(
        self, name: typing_extensions.Literal["create_time"]
    ) -> typing.Union[MetaOapg.properties.create_time, schemas.Unset]:
        ...

    @typing.overload
    def get_item_oapg(
        self, name: typing_extensions.Literal["input_submit_time"]
    ) -> typing.Union[MetaOapg.properties.input_submit_time, schemas.Unset]:
        ...

    @typing.overload
    def get_item_oapg(
        self, name: typing_extensions.Literal["start_time"]
    ) -> typing.Union[MetaOapg.properties.start_time, schemas.Unset]:
        ...

    @typing.overload
    def get_item_oapg(
        self, name: typing_extensions.Literal["computation_start_time"]
    ) -> typing.Union[MetaOapg.properties.computation_start_time,
                      schemas.Unset]:
        ...

    @typing.overload
    def get_item_oapg(
        self, name: typing_extensions.Literal["computation_end_time"]
    ) -> typing.Union[MetaOapg.properties.computation_end_time, schemas.Unset]:
        ...

    @typing.overload
    def get_item_oapg(
        self, name: typing_extensions.Literal["end_time"]
    ) -> typing.Union[MetaOapg.properties.end_time, schemas.Unset]:
        ...

    @typing.overload
    def get_item_oapg(
        self, name: typing_extensions.Literal["estimated_computation_cost"]
    ) -> typing.Union[MetaOapg.properties.estimated_computation_cost,
                      schemas.Unset]:
        ...

    @typing.overload
    def get_item_oapg(
        self, name: typing_extensions.Literal["storage_size"]
    ) -> typing.Union[MetaOapg.properties.storage_size, schemas.Unset]:
        ...

    @typing.overload
    def get_item_oapg(
        self, name: typing_extensions.Literal["metrics"]
    ) -> typing.Union[MetaOapg.properties.metrics, schemas.Unset]:
        ...

    @typing.overload
    def get_item_oapg(
        self, name: typing_extensions.Literal["executer"]
    ) -> typing.Union[MetaOapg.properties.executer, schemas.Unset]:
        ...

    @typing.overload
    def get_item_oapg(
        self, name: typing_extensions.Literal["machine_group_name"]
    ) -> typing.Union[MetaOapg.properties.machine_group_name, schemas.Unset]:
        ...

    @typing.overload
    def get_item_oapg(
        self, name: typing_extensions.Literal["machine_group_id"]
    ) -> typing.Union[MetaOapg.properties.machine_group_id, schemas.Unset]:
        ...

    @typing.overload
    def get_item_oapg(
        self, name: typing_extensions.Literal["error_detail"]
    ) -> typing.Union[MetaOapg.properties.error_detail, schemas.Unset]:
        ...

    @typing.overload
    def get_item_oapg(
        self, name: typing_extensions.Literal["input_resources"]
    ) -> typing.Union[MetaOapg.properties.input_resources, schemas.Unset]:
        ...

    @typing.overload
    def get_item_oapg(
        self, name: typing_extensions.Literal["stream_zip"]
    ) -> typing.Union[MetaOapg.properties.stream_zip, schemas.Unset]:
        ...

    @typing.overload
    def get_item_oapg(
        self, name: typing_extensions.Literal["steps"]
    ) -> typing.Union[MetaOapg.properties.steps, schemas.Unset]:
        ...

    @typing.overload
    def get_item_oapg(
            self, name: str
    ) -> typing.Union[schemas.UnsetAnyTypeSchema, schemas.Unset]:
        ...

    def get_item_oapg(self, name: typing.Union[typing_extensions.Literal[
        "task_id",
        "status",
        "status_alias",
        "simulator",
        "project",
        "is_terminated",
        "status_history",
        "machine_operations",
        "storage_path",
        "container_image",
        "create_time",
        "input_submit_time",
        "start_time",
        "computation_start_time",
        "computation_end_time",
        "end_time",
        "estimated_computation_cost",
        "storage_size",
        "metrics",
        "executer",
        "machine_group_name",
        "machine_group_id",
        "error_detail",
        "input_resources",
        "stream_zip",
        "steps",
    ], str]):
        return super().get_item_oapg(name)

    def __new__(
        cls,
        *_args: typing.Union[
            dict,
            frozendict.frozendict,
        ],
        simulator: typing.Union[
            MetaOapg.properties.simulator,
            str,
        ],
        status_alias: typing.Union[
            MetaOapg.properties.status_alias,
            str,
        ],
        status_history: typing.Union[
            MetaOapg.properties.status_history,
            list,
            tuple,
        ],
        project: typing.Union[
            MetaOapg.properties.project,
            str,
        ],
        task_id: typing.Union[
            MetaOapg.properties.task_id,
            str,
        ],
        machine_operations: typing.Union[
            MetaOapg.properties.machine_operations,
            list,
            tuple,
        ],
        is_terminated: typing.Union[
            MetaOapg.properties.is_terminated,
            bool,
        ],
        status: 'TaskStatusCode',
        storage_path: typing.Union[MetaOapg.properties.storage_path, dict,
                                   frozendict.frozendict, str, date, datetime,
                                   uuid.UUID, int, float, decimal.Decimal, bool,
                                   None, list, tuple, bytes, io.FileIO,
                                   io.BufferedReader,
                                   schemas.Unset] = schemas.unset,
        container_image: typing.Union[MetaOapg.properties.container_image, dict,
                                      frozendict.frozendict, str, date,
                                      datetime, uuid.UUID, int, float,
                                      decimal.Decimal, bool, None, list, tuple,
                                      bytes, io.FileIO, io.BufferedReader,
                                      schemas.Unset] = schemas.unset,
        create_time: typing.Union[MetaOapg.properties.create_time, dict,
                                  frozendict.frozendict, str, date, datetime,
                                  uuid.UUID, int, float, decimal.Decimal, bool,
                                  None, list, tuple, bytes, io.FileIO,
                                  io.BufferedReader,
                                  schemas.Unset] = schemas.unset,
        input_submit_time: typing.Union[MetaOapg.properties.input_submit_time,
                                        dict, frozendict.frozendict, str, date,
                                        datetime, uuid.UUID, int, float,
                                        decimal.Decimal, bool, None, list,
                                        tuple, bytes, io.FileIO,
                                        io.BufferedReader,
                                        schemas.Unset] = schemas.unset,
        start_time: typing.Union[MetaOapg.properties.start_time, dict,
                                 frozendict.frozendict, str, date, datetime,
                                 uuid.UUID, int, float, decimal.Decimal, bool,
                                 None, list, tuple, bytes, io.FileIO,
                                 io.BufferedReader,
                                 schemas.Unset] = schemas.unset,
        computation_start_time: typing.Union[
            MetaOapg.properties.computation_start_time, dict,
            frozendict.frozendict, str, date, datetime, uuid.UUID, int, float,
            decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO,
            io.BufferedReader, schemas.Unset] = schemas.unset,
        computation_end_time: typing.Union[
            MetaOapg.properties.computation_end_time, dict,
            frozendict.frozendict, str, date, datetime, uuid.UUID, int, float,
            decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO,
            io.BufferedReader, schemas.Unset] = schemas.unset,
        end_time: typing.Union[MetaOapg.properties.end_time, dict,
                               frozendict.frozendict, str, date, datetime,
                               uuid.UUID, int, float, decimal.Decimal, bool,
                               None, list, tuple, bytes, io.FileIO,
                               io.BufferedReader,
                               schemas.Unset] = schemas.unset,
        estimated_computation_cost: typing.Union[
            MetaOapg.properties.estimated_computation_cost, dict,
            frozendict.frozendict, str, date, datetime, uuid.UUID, int, float,
            decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO,
            io.BufferedReader, schemas.Unset] = schemas.unset,
        storage_size: typing.Union[MetaOapg.properties.storage_size, dict,
                                   frozendict.frozendict, str, date, datetime,
                                   uuid.UUID, int, float, decimal.Decimal, bool,
                                   None, list, tuple, bytes, io.FileIO,
                                   io.BufferedReader,
                                   schemas.Unset] = schemas.unset,
        metrics: typing.Union[MetaOapg.properties.metrics, dict,
                              frozendict.frozendict, str, date, datetime,
                              uuid.UUID, int, float, decimal.Decimal, bool,
                              None, list, tuple, bytes, io.FileIO,
                              io.BufferedReader, schemas.Unset] = schemas.unset,
        executer: typing.Union[MetaOapg.properties.executer, dict,
                               frozendict.frozendict, str, date, datetime,
                               uuid.UUID, int, float, decimal.Decimal, bool,
                               None, list, tuple, bytes, io.FileIO,
                               io.BufferedReader,
                               schemas.Unset] = schemas.unset,
        machine_group_name: typing.Union[MetaOapg.properties.machine_group_name,
                                         dict, frozendict.frozendict, str, date,
                                         datetime, uuid.UUID, int, float,
                                         decimal.Decimal, bool, None, list,
                                         tuple, bytes, io.FileIO,
                                         io.BufferedReader,
                                         schemas.Unset] = schemas.unset,
        machine_group_id: typing.Union[MetaOapg.properties.machine_group_id,
                                       dict, frozendict.frozendict, str, date,
                                       datetime, uuid.UUID, int, float,
                                       decimal.Decimal, bool, None, list, tuple,
                                       bytes, io.FileIO, io.BufferedReader,
                                       schemas.Unset] = schemas.unset,
        error_detail: typing.Union[MetaOapg.properties.error_detail, dict,
                                   frozendict.frozendict, str, date, datetime,
                                   uuid.UUID, int, float, decimal.Decimal, bool,
                                   None, list, tuple, bytes, io.FileIO,
                                   io.BufferedReader,
                                   schemas.Unset] = schemas.unset,
        input_resources: typing.Union[MetaOapg.properties.input_resources, list,
                                      tuple, schemas.Unset] = schemas.unset,
        stream_zip: typing.Union[MetaOapg.properties.stream_zip, bool,
                                 schemas.Unset] = schemas.unset,
        steps: typing.Union[MetaOapg.properties.steps, list, tuple,
                            schemas.Unset] = schemas.unset,
        _configuration: typing.Optional[schemas.Configuration] = None,
        **kwargs: typing.Union[schemas.AnyTypeSchema, dict,
                               frozendict.frozendict, str, date, datetime,
                               uuid.UUID, int, float, decimal.Decimal, None,
                               list, tuple, bytes],
    ) -> 'TaskWithStatusHistory':
        return super().__new__(
            cls,
            *_args,
            simulator=simulator,
            status_alias=status_alias,
            status_history=status_history,
            project=project,
            task_id=task_id,
            machine_operations=machine_operations,
            is_terminated=is_terminated,
            status=status,
            storage_path=storage_path,
            container_image=container_image,
            create_time=create_time,
            input_submit_time=input_submit_time,
            start_time=start_time,
            computation_start_time=computation_start_time,
            computation_end_time=computation_end_time,
            end_time=end_time,
            estimated_computation_cost=estimated_computation_cost,
            storage_size=storage_size,
            metrics=metrics,
            executer=executer,
            machine_group_name=machine_group_name,
            machine_group_id=machine_group_id,
            error_detail=error_detail,
            input_resources=input_resources,
            stream_zip=stream_zip,
            steps=steps,
            _configuration=_configuration,
            **kwargs,
        )


from inductiva.client.model.executer import Executer
from inductiva.client.model.task_machine_operation import TaskMachineOperation
from inductiva.client.model.task_metrics import TaskMetrics
from inductiva.client.model.task_status_code import TaskStatusCode
from inductiva.client.model.task_status_info import TaskStatusInfo
from inductiva.client.model.task_step import TaskStep
