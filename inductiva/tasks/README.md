# Tasks


The **Inductiva API** client provides the ability to run complex simulations and contains easy-to-use tools to manage them. Each simulation submitted - with `scenario.simulate()` or `simulation.run()` - runs asynchronously and returns a `Task` object that contains methods to manage the simulation.

Here, you'll learn:

- [Managing tasks](#managing-tasks): the methods you can use to interact with a specific task.
- [Retrieving tasks from previous sessions](#retrieving-tasks-from-previous-sessions): getting information from previously ran tasks.

## Managing tasks

The `Task` class provides methods for managing a specific task submitted to the **Inductiva API**. You get an instance of `Task` everytime you create a simulation. Moreover, you can [retrieve previously created tasks](#retrieving-tasks-from-previous-sessions).
With a `Task` object, you can:
 * Get its status;
 * Get the machine type where it ran/is running;
 * Kill it if you've changed your mind;
 * Turning it into a blocking call;
 * Download output files (all of them or only the important ones);
 * Get its execution time.

### Examples:

```python
# `scenario` constructed as in the examples above.
# ... stands for arguments related to each specific scenario.
task = scenario.simulate(...)

# Get status of the task.
status = task.get_status()
print(status) # would be, e.g., "submitted", "started", "success", "failed", "killed"

# Get the machine type where the task is running.
machine_type = task.get_machine_type()
print(machine_type) # e.g., "c2-standard-4", "c2d-standard-16"

# Kill a task that hasn't completed yet.
if status == "submitted" or status == "started":
    task.kill()
```

```python

task = my_scenario.simulate()
# Block the call until the simulation completes, but
# without interrupting the remote task if the local process
# is interrupted. 
task.wait()

# Turn the simulation into a blocking call. Users kill
# the remote process if the local process is killed.
task = my_scenario.simulate()
with task.sync_context():
    task.wait()
```


```python

task = scenario.simulate(...)

# To obtain the simulation results, you can download the output files via:
task.download_outputs(output_dir="path/to/save/outputs")

# If you don't know the files generated by your task, you can get an object
# representing information on the output files.
outputs_info = task.get_output_files_info()

full_download_size = outputs_info.size # Size of the full output archive.
files = outputs_info.contents # List of individual files available.

# Pretty print information on the output archive.
print(outputs_info)
# Archive size: 1.64 GiB
# Contents:
#  Size         Compressed   Name
#  191 B        96 B         stderr.txt
#  138.24 KiB   16.73 KiB    stdout.txt
# ...
#  3.80 MiB     3.61 MiB     important_file1.txt
#  1.27 MiB     1.21 MiB     important_file2.txt


# Download only those you are interested in:
output_dir = task.download_outputs(
    filenames=["important_file1.txt", "important_file2.txt"])
# 100%|██████████| 4.82M/4.82M [00:00<00:00, 273MiB/s]

# Or all the generated files for archival, without extracting the
# downloaded zip.
output_dir = task.download_outputs(uncompress=False)
# 100%|██████████| 1.64G/1.64G [00:32<00:00, 55.1MiB/s]
```

## Retrieving tasks from previous sessions

A fundamental aspect of the API is that all tasks run asynchronously.
To retrieve previously created tasks and reconstruct the `Task` objects - the object you get from `scenario.simulate()` -  use the `inductiva.tasks.get()` function.
It requires an argument named `last_n`, which specifies the number of most recent tasks submitted to the API to retrieve. It returns a list of `Task` objects so that you can resume manipulating the task and its results.
Additionally, you can filter tasks by their current status, which allows you to get, for instance, only tasks that failed or only
tasks that are submitted and not yet started.

### Examples:

```python
import inductiva

# Get my last 10 submitted tasks.
tasks = inductiva.tasks.get(last_n=10)

# Get my last 10 tasks that ran successfuly.
tasks = inductiva.tasks.get(last_n=10, status="success")

# You can use the task objects to manipulate the tasks.
not_started_tasks = inductiva.tasks.get(last_n=5, status="submitted")
for task in not_started_tasks:
    task.kill()

successful_tasks = inductiva.tasks.get(last_n=20, status="success")
for task in successful_tasks:
    task.download_outputs()
```

Another function named `list`, which shares the same arguments as `get`, can be used to print information about the
tasks in tabular format to the console. The tasks time with an asterisk (*) means that the task is still running.

```python
import inductiva

# list the last 5 tasks that were successful
inductiva.tasks.list(5)
#                       ID           Simulator     Status          Submitted          Picked-Up Computation Time  Total Duration            VM Type
#on61z6u9c17uatqnbios7zjo3 openfoam_foundation    success   12 Jan, 10:27:19   12 Jan, 10:27:42        0h 2m 20s       0h 2m 50s   c2d-standard-112
#u43sobjkk906566xzmm1x8x8t openfoam_foundation     killed   12 Jan, 10:21:51   12 Jan, 10:22:39        0h 1m 42s        0h 2m 8s   c2d-standard-112
#k56bidnib55bkiv5jpmo0cp3z openfoam_foundation    started   12 Jan, 10:20:14   12 Jan, 10:22:39       *0h 7m 58s      *0h 7m 58s   c2d-standard-112
#kgrc1ejk3q80fsh1k2hdgkxjg openfoam_foundation    success   12 Jan, 10:09:25   12 Jan, 10:09:50         0h 7m 8s       0h 7m 38s     c2-standard-30
#asi7pn43977wzitcu8j848vbq openfoam_foundation    success   12 Jan, 09:44:30   12 Jan, 09:44:54        0h 8m 59s       0h 9m 32s     c2-standard-16
```
