"Postprocessing steps for the MDWaterBox scenario."
import os
import pathlib
import time
import typing

import matplotlib.pyplot as plt
import MDAnalysis as mda
import nglview as nv
import numpy as np

import inductiva

FULL_TRAJECTORY_FILE = "full_trajectory.trr"
COMPRESSED_TRAJECTORY_FILE = "compressed_trajectory.xtc"
TOPOLOGY_FILE = "solvated_protein.tpr"


class ProteinSolvationOutput:
    """Post process the simulation output of a ProteinSolvation scenario."""

    def __init__(self, sim_output_path: pathlib.Path = None):
        """Initializes a `ProteinSolvationOutput` object.

        Given a simulation output directory that contains the standard files
        generated by a ProteinSolvation simulation run, this class provides 
        methods to visualize the simulation outputs in a notebook interactively.

        Args:
            sim_output_path: Path to the simulation output directory."""

        self.sim_output_dir = sim_output_path

    def render_interactive(
            self,
            representation: typing.Literal["cartoon", "ball+stick", "line",
                                           "point", "surface",
                                           "ribbon"] = "ball+stick",
            selection: str = "protein",
            use_compressed_trajectory: bool = False,
            add_backbone: bool = True):
        """
        Render the simulation outputs in an interactive visualization.
        Args: 
            representation: The protein representation to use for the 
            visualization.
            selection: The selection to use for the representation. Check 
            https://nglviewer.org/ngl/api/manual/usage/selection-language.html 
            for details.
            add_backbone: Whether to add the protein backbone to the 
            visualization.
            use_compressed_trajectory: Whether to use the compressed 
            trajectory or the full precision one.
            """
        universe = self.construct_universe(use_compressed_trajectory)
        protein = universe.select_atoms("protein")
        view = nv.show_mdanalysis(protein)
        view.add_representation(representation, selection=selection)
        if add_backbone:  #hardcoding the backbone as a cartoon representation
            view.add_representation("cartoon", selection="protein")
        view.center()

        print("System Information: ")
        print(f"Number of atoms in the system: {len(universe.atoms)}")
        print(f"Number of amino acids: "
              f"{universe.select_atoms('protein').n_residues}")
        print(f"Number of solvent molecules:"
              f"{universe.select_atoms('not protein').n_residues}")
        print(f"Number of trajectory frames: {len(universe.trajectory)}")
        return view

    def construct_universe(self, use_compressed_trajectory: bool = False):
        """Construct a MDAnalysis universe from the simulation output.

        Args:
            use_compressed_trajectory: Whether to use the compressed trajectory
            or the full precision trajectory."""
        topology_path = os.path.join(self.sim_output_dir, TOPOLOGY_FILE)
        if use_compressed_trajectory:
            trajectory_path = os.path.join(self.sim_output_dir,
                                           COMPRESSED_TRAJECTORY_FILE)
        else:
            trajectory_path = os.path.join(self.sim_output_dir,
                                           FULL_TRAJECTORY_FILE)
        universe = inductiva.molecules.scenarios.utils.unwrap_trajectory(
            topology_path, trajectory_path)
        return universe

    def calculate_rmsf_trajectory(self,
                                  use_compressed_trajectory: bool = False):
        """Calculate the root mean square fluctuation (RMSF) over a trajectory.  

        It is typically calculated for the alpha carbon atom of each residue. 
        These atoms make the backbone of the protein.The RMSF is the square root 
        of the variance of the fluctuation around the average position:
        &rhoi = √⟨(xi - ⟨xi⟩)²⟩
        It quantifies how much a structure diverges from the average structure 
        over time, the RSMF can reveal which areas of the system are the most 
        mobile. Check 
        https://userguide.mdanalysis.org/stable/examples/analysis/alignment_and_rms/rmsf.html 
        for more details.

        Args:
            nglview_visualization: Whether to return visualization of the 
            RMSF using nglview or not."""
        start_time = time.time()
        universe = self.construct_universe(use_compressed_trajectory)
        topology_path = os.path.join(self.sim_output_dir, TOPOLOGY_FILE)

        aligned_trajectory_path = os.path.join(self.sim_output_dir,
                                               "aligned_traj.dcd")
        inductiva.molecules.scenarios.utils.align_trajectory_to_average(
            universe, aligned_trajectory_path)
        align_universe = mda.Universe(topology_path, aligned_trajectory_path)

        # Calculate RMSF for carbon alpha atoms
        c_alphas = align_universe.select_atoms("protein and name CA")
        rmsf = mda.analysis.rms.RMSF(c_alphas).run()
        rmsf_values = rmsf.results.rmsf
        duration = time.time() - start_time
        print(f"RMSF calculation took {duration:.2f} seconds.")
        return rmsf_values

    def plot_rmsf_per_residue(self, rmsf_values: np.array):
        "Plot RMSF values per residue."
        # Plot the data
        residue_number = np.arange(len(rmsf_values))
        plt.plot(residue_number, rmsf_values)
        plt.xlabel("Residue Number")
        plt.ylabel("RMSF")
        plt.title("RMSF per residue")
        plt.grid(True)
        plt.show()

    def render_attribute_per_residue(
            self,
            residue_attributes: np.ndarray,
            representation: typing.Literal["cartoon", "ball+stick", "line",
                                           "point", "surface",
                                           "ribbon"] = "cartoon",
            use_compressed_trajectory: bool = False):
        """Render a specific protein attribute in an interactive visualization.
        Args: 
            residue_attributes: The per residue values of the attribute you want 
            to visualize.
            representation: The protein representation to use for the 
            visualization.
            use_compressed_trajectory: Whether to use the compressed trajectory 
            or the full precision trajectory.
            """
        universe = self.construct_universe(use_compressed_trajectory)
        universe.add_TopologyAttr("tempfactors")
        protein = universe.select_atoms("protein")
        for residue, value in zip(protein.residues, residue_attributes):
            residue.atoms.tempfactors = value
        view = nv.show_mdanalysis(universe)
        view.add_representation(representation, selection="protein")
        view.update_representation(color_scheme="bfactor")
        view.center()
        return view
